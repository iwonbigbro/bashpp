#!/bin/bash

# Copyright (C) 2015 Craig Phillips.  All rights reserved.

set -euo pipefail

exec 100<&0

bashpp=$(readlink -f "$BASH_SOURCE")
bashpp_dir=${bashpp%/*}

BASHINC=${BASHINC:-}

declare -A DEFS=()
declare -A MACROS=()
declare -A DIRS=(
    ["define"]=1
    ["undef"]=1
)

output="/dev/stdout"

VERBOSE=${VERBOSE:-0}
DEBUG=${DEBUG:-0}
DEBUG_LINENO=${DEBUG_LINENO:-0}
ERROR_LINE=${ERROR_LINE:-1}
ERROR_MAX=${ERROR_MAX:-10}
BUF_MAX=${BUF_MAX:-4096}
FILE_MAX=${FILE_MAX:-0}

OUTPUT_LINES=0
SECONDS=0

if (( BUF_MAX > FILE_MAX )) ; then
    BUF_MAX=$FILE_MAX
fi

CR=$'\r'
LF=$'\n'

errors=0
warnings=0
msg_lines=0

tty_stdout=0
tty_stderr=0
tty_stdin=0
tty=0

if [[ -t 0 ]] ; then
    tty_stdin=1
    tty=1
fi

if [[ -t 1 ]] ; then
    tty_stdout=1
    tty=1
fi

if [[ -t 2 ]] ; then
    tty_stderr=1
    tty=1
fi

lineno=1
charno=1
flushed=0

states=0
while read state ; do
    printf -v $state "%d" $states

    (( ++states ))
done <<STATES
apos
arithmetic
bracket_s
bracket_c
comment
directive
directive_escape
dollar
escape
escape_sequence
expandbrace
expandcmd
expandparam
expandvar
heredoc_inline
heredoc_tag
heredoc_tagged
heredoc
conditional
conditional_operator
conditional_regex
number
parens
parsing
parsing_string
quote
redirect_in
redirect_out
tick
word
eof
STATES

unset state
state_stack=()
state_stackbuf=()
state_stacklen=0
st_name="eof"
st_charno=1
st_buf=
st_buf_prev=
st=$eof

heredoc_stack=( "<empty>" )
heredoc_stacktype=()
heredoc_stacklen=0
hd_inline=0
hd_buf=
hd=

flushbuf=0
freezebuf=0

files=()

filesize=
errline=
buf=

function assoc_arrcpy() {
    declare -p $1 | sed 's?^[^=]\+=??'
}

function msgtype_colour() {
    local tag=$1
    local on= off=

    if (( tty )) ; then
        case $1 in
        (stop*)      on="[1m[38;5;124m" ;;
        (error*)     on="[1m[38;5;167m" ;;
        (warning*)   on="[1m[38;5;213m" ;;
        (info*)      on="[1m[38;5;106m" ;;
        (debug*)     on="[1m[38;5;105m" ;;
        esac

        off="[39m[0m"
    fi

    printf "${on}%s${off}" "$tag"
}

function bashpp_msg() {
    local msgtype=$1
    shift

    local funcname=${FUNCNAME[1]:-main}

    if [[ $funcname == +(msg|die|debug|info|warn)* ]] ; then
        funcname=${FUNCNAME[2]:-main}
    fi

    printf >&2 "${bashpp##*/}: $msgtype:${funcname:+ $funcname:} %s\n" \
        "${*///^[}"
}

function msg_errorline() {
    local stdin=$1

    if (( stdin )) ; then
        local cc=
        while getc cc ; do
            if [[ $cc == $'\n' ]] ; then
                break
            fi

            errline+=$cc
        done
    else
        errline=$(awk 'NR == '$lineno' { print ; exit }' "$file")
    fi

    local indicator=${errline:0:$charno}
          indicator=${indicator///^[}
          indicator=${indicator//?/.}
          indicator=${indicator%.}^

    printf >&2 "  %s\n" "${errline///^[}" "$indicator"

    errline=
}

function msg() {
    local msgtype=$1
    local msgtype_colour=$(msgtype_colour "$msgtype")
    local show_errorline=1
    shift

    if [[ ! ${file:-} ]] ; then
        bashpp_msg "$msgtype_colour" "$*"
    else
        if [[ $msgtype != +(error|warning) ]] ; then
            show_errorline=0
        fi
            
        if [[ $file == "/dev/stdin" ]] ; then
            printf >&2 "<stdin>:$lineno:$charno $msgtype_colour: %s\n"
                "${*///^[}"

            if (( show_errorline )) ; then
                msg_errorline 1
            fi
        else
            printf >&2 "$file:$lineno:$charno $msgtype_colour: %s\n" \
                "${*///^[}"

            if (( show_errorline )) ; then
                msg_errorline 0
            fi
        fi
    fi
}

function err() {
    if (( lineno == 0 )) ; then
        die "$@"
    fi

    (( ++errors )) || true

    msg "error" "$errors: $*"

    if (( errors >= ERROR_MAX )) ; then
        local p=$(( ( fileoffset * 100 ) / filesize ))

        msg "stop" "stopping at ${p}%, too many errors"
        exit 1
    fi
}

function stacktrace() {
    local i=-1 total=0

    if (( $# )) ; then
        printf >&2 "[1m[38;5;167mTraceback:[0m\n"
        printf >&2 "  [38;5;167m%s:%d: %s()[0m\n" "$@"

        (( ++total )) || true
    fi


    while (( ++i < ${#BASH_LINENO[@]} )) ; do
        if [[ ${FUNCNAME[i]} == +(main|die|stacktrace) ]] ; then
            continue
        elif [[ ! ${FUNCNAME[i]} ]] ; then
            continue
        fi

        if (( ++total == 1 )) ; then
            printf >&2 "[1m[38;5;167mTraceback:[0m\n"
        fi

        printf >&2 "  [38;5;167m%s:%d: %s()[0m\n" \
            "${BASH_SOURCE[i+1]:-$BASH_SOURCE}" \
            "${BASH_LINENO[i]}" \
            "${FUNCNAME[i]}"
    done
}

set -E
trap 'stacktrace "$BASH_SOURCE" "$LINENO" "${FUNCNAME:-main}"' ERR

function die() {
    local funcname=${FUNCNAME[1]:-}
          funcname=${funcname:+$funcname }

    stacktrace
    bashpp_msg "$(msgtype_colour "error")" "$*"

    exit 1
}

if (( BASH_VERSINFO[0] < 4 || ( BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 1 ) )) ; then
    die "minimum version '4.1' required"
fi

function warn() {
    (( ++warnings ))

    msg "warning" "$*"
}

function info() {
    if (( VERBOSE )) ; then
        msg "info" "$*"
    fi
}

function debug() {
    if (( DEBUG )) ; then
        if (( DEBUG_LINENO > 0 && lineno < DEBUG_LINENO )) ; then
            return
        fi

        msg "debug" "${FUNCNAME[1]:-main}(): $*"
    fi
}

function debug_l() {
    if (( DEBUG > $1 )) ; then
        local l=$1
        shift

        if (( DEBUG_LINENO > 0 && lineno < DEBUG_LINENO )) ; then
            return
        fi

        msg "debug_$l" "${FUNCNAME[1]:-main}(): $*"
    fi
}

if (( BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2 )) ; then
    # Features supported in version 4.2+:
    #     \uXXXX and \UXXXXXXXX
    #     declare -g
    #     test -v
    #     printf %(fmt)T
    #     ${array[-idx]} and ${var:start:-len}
    #     lastpipe (shopt)
    function substr() {
        local str=${!1}
        local strlen=${#str} \
              offset=${2:-} \
              length=${3:--1}

        if (( length < 0 )) ; then
            if (( offset < 0 )) ; then
                length=$(( offset * -1 ))
            else
                length=$(( strlen - offset ))
            fi
        fi

        if (( offset < 0 )) ; then
            offset=$(( strlen + offset ))
        fi

        printf "%s" "${str:$offset:$length}"
    }
else
    function substr() {
        local str=${!1}
        local strlen=${#str} \
              offset=${2:-} \
              length=${3:--1}

        if (( length > -1 )) ; then
            printf "%s" "${str:$offset:$length}"
        else
            printf "%s" "${str: $offset}"
        fi
    }
fi

function add_include_dir() {
    if [[ ! $1 ]] ; then
        die "No directory specified"
    elif [[ ! -d $1 ]] ; then
        die "No such directory: $1"
    fi

    if [[ ":${BASHINC:-}:" != *":$1:"* ]] ; then
        BASHINC+=":$1"
    fi
}

function definefn() {
    err "macro functions currently not supported"
}

function is_define() {
    (( ${#DEFS[$1]:-} > 0 ))
}

function is_macro() {
    (( ${#MACROS[$1]:-} > 0 ))
}

function define() {
    local name=${1%%(*} \
          parens=${1#*(} \
          define=${2:-1}

    if ! [[ $name =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]] ; then
        err "illegal definition name: $name"
    fi

    if [[ $1 == *"("* ]] ; then
        definefn "$name" "${parens%)}" "$define"
        return 0
    fi

    info "-D $name=$define"

    DEFS[$name]=$define
}

function undef() {
    info "-U $1"

    unset DEFS[$1]
    unset MACROS[$1]
}

function add_define() {
    local name=${1%%=*} \
          define=${1#*=}

    if [[ $1 == *"="* ]] ; then
        define "${1%%=*}" "${1#*=}"
    else
        define "$1" 1
    fi
}

function remove_define() {
    undef "$1"
}

function push_state() {
    local char=${c:-}
    debug "$st_name -> $1: '${st_buf##*${LF}}${c:-}'"

    state_stackbuf+=( "$st_buf" )
    state_stack+=( $st_name )

    (( ++state_stacklen )) || true

    st=${!1}
    st_name=$1
    st_charno=1
    st_buf_prev=$st_buf
    st_buf=
}

function pop_state() {
    if (( ${#state_stack[@]} == 0 )) ; then
        die "state_stack accounting error"
    fi

    # For compatibility with Bash versions < 4.2
    local i=$state_stacklen
    (( --i )) || true

    debug "$st_name -> ${state_stack[i]}: '${st_buf##*${LF}}${c:-}'"

    st_name=${state_stack[i]}
    st_buf_prev=$st_buf
    st_buf=${state_stackbuf[i]}
    st_charno=${#st_buf}
    st=${!st_name}

    unset state_stack[i]
    unset state_stackbuf[i]

    (( --state_stacklen )) || true
}

function switch_state() {
    debug "$st_name -> $1: '${st_buf##*${LF}}${c:-}'"

    st=${!1}
    st_name=$1
}

function push_heredoc() {
    IFS=: debug "${heredoc_stack[@]} -> ${heredoc_stack[@]}:$1"

    if [[ $1 == "'"*"'" ]] ; then
        hd_type=$apos
    else
        hd_type=$quote
    fi

    hd=$1

    heredoc_stacktype+=( "$hd_type" )
    heredoc_stack+=( $hd )

    (( ++heredoc_stacklen )) || true
}

function pop_heredoc() {
    if (( ${#heredoc_stack[@]} == 1 )) ; then
        die "heredoc_stack accounting error"
    fi

    local cur_hd=$hd

    # For compatibility with Bash versions < 4.2
    local i=$heredoc_stacklen
    (( --i )) || true

    hd=${heredoc_stack[i]}
    hd_type=${heredoc_stacktype[i]}

    unset heredoc_stack[i]
    unset heredoc_stackbuf[i]

    (( --heredoc_stacklen )) || true

    IFS=: debug "${heredoc_stack[@]}:$cur_hd -> ${heredoc_stack[@]}"
}

function freeze_buf() {
    debug
    freezebuf_buf=

    if (( freezebuf )) ; then
        die "attempted to refreeze buffer"
    fi

    freezebuf=1
}

function thaw_buf() {
    debug "${#freezebuf_buf} bytes thawed"

    if (( ! freezebuf )) ; then
        die "attempted to rethaw buffer"
    fi

    freezebuf=0
}

function push_buf() {
    st_buf+=$1

    if (( SECONDS > 0 )) ; then
        local p=$(( ( fileoffset * 100 ) / filesize ))

        info "${p}% complete - current state = '$st_name'"

        SECONDS=0
    fi

    if (( freezebuf == 1 )) ; then
        freezebuf_buf+=$1
    else
        buf+=$1

        if (( flushbuf || ${#buf} > BUF_MAX )) ; then
            printf "%s" "$buf"

            flushbuf=0
            buf=
        fi

        if (( FILE_MAX > 0 && fileoffset > FILE_MAX )) ; then
            info "stopping at $fileoffset bytes"
            exit 1
        fi
    fi
}

function flush_buf() {
    if (( ${1:-0} )) ; then
        printf "%s" "$buf"

        flushbuf=0
        buf=
    else
        flushbuf=1
    fi
}

function process_define() {
    local args=$1

    if [[ $args =~ ^([A-Za-z_][A-Za-z0-9_]*)[\ \t]+(.*)$ ]] ; then
        define "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
        return

    elif [[ $args =~ ^([A-Za-z_][A-Za-z0-9_]*)$ ]] ; then
        define "${BASH_REMATCH[1]}" 1
        return

    fi

    err "illegal define: $line"

    return 1
}

function check_escape_sequence() {
    if [[ $c == '' ]] ; then
        push_state escape_sequence
        push_buf "$c"

        return 0
    fi

    return 1
}

function process_char_state_parsing() {
    if [[ $c == '#' ]] ; then
        if (( charno == 1 )) ; then
            push_state directive
            freeze_buf
        else
            push_state comment
        fi
    elif [[ $c == '$' ]] ; then
        push_state dollar
    elif [[ $c == '`' ]] ; then
        push_state tick
    elif [[ $c == '(' ]] ; then
        push_state parens
    elif [[ $c == '{' ]] ; then
        push_state bracket_c
    elif [[ $c == '[' ]] ; then
        push_state bracket_s
    elif [[ $c == '"' ]] ; then
        push_state quote
    elif [[ $c == "'" ]] ; then
        push_state apos
    elif [[ $c == '<' ]] ; then
        push_state redirect_in
    elif [[ $c == '>' ]] ; then
        push_state redirect_out
    elif [[ $c == [A-Za-z_] ]] ; then
        push_state word
        freeze_buf
    fi
}

function process_char() {
    local c=$1

    debug_l 2 "$c"

    if (( st == apos )) ; then
        if [[ $c == "'" ]] ; then
            pop_state
        elif check_escape_sequence ; then
            return 0
        fi
    elif (( st == arithmetic )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == '(' ]] ; then
            push_state parens
        elif [[ $c == ')' && $(substr st_buf -1) == ')' ]] ; then
            pop_state
        fi
    elif (( st == bracket_c )) ; then
        if [[ $c == '}' ]] ; then
            pop_state
        else
            process_char_state_parsing
        fi
    elif (( st == bracket_s )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == '[' ]] ; then
            switch_state conditional
        elif [[ $c == ']' ]] ; then
            pop_state
        fi
    elif (( st == comment )) ; then
        if [[ $c == $'\n' ]] ; then
            pop_state
        fi
    elif (( st == conditional )) ; then
        if (( st_charno == 1 )) ; then
            if [[ $c != ' ' ]] ; then
                warn "missing whitespace in conditional expression"

                if [[ $c == [\-=\!\<\>] ]] ; then
                    push_state conditional_operator
                fi
            fi
        fi

        if [[ $(substr st_buf -1) == ' ' && $c == [\-\!=] ]] ; then
            push_state conditional_operator
        elif [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == "'" ]] ; then
            push_state apos
        elif [[ $c == '"' ]] ; then
            push_state quote
        elif [[ $c == '(' ]] ; then
            push_state parens
        elif [[ $c == ')' && $(substr st_buf -1) == ')' ]] ; then
            pop_state
        elif [[ $c == ']' && $(substr st_buf -1) == ']' ]] ; then
            pop_state
        fi
    elif (( st == conditional_operator )) ; then
        if [[ $c == $LF || $c == ' ' ]] ; then
            case $st_buf in
            (-[abcdefghklnoprstuvwxzGLNORS]) ;;
            (-ef|-eq|-ge|-gt|-le|-lt|-ne|-nt|-ot) ;;
            (==|!=|!|\&\&|\|\||\|\&) ;;
            (=~)
                push_buf "$c"
                switch_state conditional_regex

                return 0
                ;;
            (=)
                warn "posix operator in non-posix conditional"
                ;;
            (*)
                err "unrecognized operator: '$st_buf'"
                ;;
            esac

            pop_state
            process_char "$c"

            return 0
        fi
    elif (( st == conditional_regex )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == $LF ]] ; then
            err "unexpected new-line in regular expression"
            pop_state
        elif [[ $c == ' ' ]] ; then
            pop_state
            process_char "$c"

            return 0
        fi
    elif (( st == directive )) ; then
        if (( st_charno == 2 )) && [[ $c != [a-z] ]] ; then
            thaw_buf
            switch_state comment
            push_buf "$freezebuf_buf"
        elif [[ $c == '\' ]] ; then
            push_state directive_escape
        elif [[ $c == $'\n' ]] ; then
            thaw_buf

            local directive= directive_params=
            read directive directive_params <<<"$(subsr freezebuf_buf 1)"

            pop_state

            if (( ${DIRS[$directive]:-0} == 1 )) ; then
                if process_$directive "$directive_params" ; then
                    return 0
                fi
            else
                err "invalid directive: $directive"
            fi

            push_buf "$freezebuf_buf"
        fi
    elif (( st == directive_escape )) ; then
        pop_state
        push_buf "\\$c"
        
        return 0
    elif (( st == dollar )) ; then
        pop_state

        if [[ $c == [*@\#\?\-\$\!0-9] ]] ; then
            true
        elif [[ $c == "'" ]] ; then
            push_state apos
        elif [[ $c == '"' ]] ; then
            push_state quote
        elif [[ $c == '{' ]] ; then
            push_state expandparam
        elif [[ $c == '(' ]] ; then
            push_state expandcmd
        elif [[ $c == [A-Za-z_] ]] ; then
            push_state expandvar
        else
            err "unexpected token in parameter expansion"
        fi
    elif (( st == escape )) ; then
        push_buf "$c"
        pop_state

        return 0
    elif (( st == escape_sequence )) ; then
        push_buf "$c"

        if (( st_charno == 2 )) ; then
            if [[ $c == '[' ]] ; then
                return 0
            fi
        else
            if [[ $c == [0-9\;] ]] ; then
                return 0
            elif [[ $c == 'm' ]] ; then
                pop_state
                return 0
            fi
        fi

        warn "unexpected character in escape sequence"

        pop_state
        process_char "$c"

        return 0
    elif (( st == expandcmd )) ; then
        if (( st_charno == 1 )) && [[ $c == '(' ]] ; then
            switch_state arithmetic
        elif [[ $c == ')' ]] ; then
            pop_state
        fi
    elif (( st == expandparam )) ; then
        if (( st_charno == 1 )) ; then
            if [[ $c != [A-Za-z0-9_\!\*\@] && $c != '#' ]] ; then
                err "malformed parameter expansion expression"
            fi
        elif (( st_charno == 2 )) && [[ $st_buf == [0-9] ]] ; then
            if [[ $c != '}' ]] ; then
                err "malformed parameter expansion expression"
            fi

        # TODO: Handle expressions.

        elif [[ $c == '}' ]] ; then
            pop_state
        fi
    elif (( st == expandvar )) ; then
        if [[ $c != [A-Za-z0-9_] ]] ; then
            pop_state
            process_char "$c"

            return 0
        fi
    elif (( st == heredoc )) ; then
        if [[ $c == $'\n' ]] ; then
            if [[ $hd_buf == $hd ]] ; then
                pop_heredoc
            fi

            hd_buf=
        else
            if (( hd_type == quote )) ; then
                if [[ $c == '$' ]] ; then
                    push_state dollar
                elif [[ $c == '`' ]] ; then
                    push_state tick
                fi
            fi

            hd_buf+="$c"
        fi
    elif (( st == heredoc_inline )) ; then
        if (( hd_inline == 0 )) ; then
            if [[ $c == '<' || $c == $'\n' ]] ; then
                pop_state
                err "unexpected character in inline heredoc"
            else
                hd_inline=1
                push_state parsing_string
            fi
        elif (( hd_inline == 1 )) ; then
            hd_inline=0
            pop_state

            if [[ $c == '<' ]] ; then
                err "unexpected redirect in inline heredoc"
            fi
        fi
    elif (( st == heredoc_tag )) ; then
        if (( st_charno == 1 )) && [[ $c == '<' ]] ; then
            switch_state heredoc_inline
        else
            switch_state heredoc_tagged
            push_state parsing_string
        fi
    elif (( st == heredoc_tagged )) ; then
        if [[ $st_buf_prev == *$'\n'* ]] ; then
            warn "heredocument contains new-line"
        fi

        push_heredoc "$st_buf_prev"
        pop_state
    elif (( st == number )) ; then
        if [[ $c != [0-9] ]] ; then
            pop_state
            process_char "$c"

            return 0
        fi
    elif (( st == parens )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == '(' ]] ; then
            switch_state arithmetic
        elif [[ $c == ')' ]] ; then
            pop_state
        fi
    elif (( st == parsing )) ; then
        process_char_state_parsing
    elif (( st == parsing_string )) ; then
        if [[ $c == [\t\ ] || $c == $'\n' ]] ; then
            pop_state
            process_char "$c"

            return 0
        fi

        process_char_state_parsing
    elif (( st == quote )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == '$' ]] ; then
            push_state dollar
        elif [[ $c == '`' ]] ; then
            push_state tick
        elif [[ $c == '"' ]] ; then
            #err "endquote"
            pop_state
        fi
    elif (( st == redirect_in )) ; then
        if [[ $c == '<' ]] ; then
            push_state heredoc_tag
        else
            pop_state
        fi
    elif (( st == redirect_out )) ; then
        if (( st_charno == 1 )) ; then
            if [[ $c == '>' ]] ; then
                # Append mode.
                true
            fi
        elif (( st_charno == 2 )) ; then
            if [[ $c == '>' ]] ; then
                err "illegal redirect"
            fi

            pop_state
        fi
    elif (( st == tick )) ; then
        if [[ $c == '`' ]] ; then
            pop_state
        else
            process_char_state_parsing
        fi
    elif (( st == word )) ; then
        if [[ $c != [0-9A-Za-z_] ]] ; then
            pop_state
            thaw_buf

            debug "word = '$freezebuf_buf'"

            if is_define "$freezebuf_buf" ; then
                debug "substituting '$freezebuf_buf' with '${DEFS[$freezebuf_buf]}'"
                push_buf "${DEFS[$freezebuf_buf]}"
            else
                push_buf "$freezebuf_buf"
            fi

            process_char "$c"

            return 0
        fi
    fi

    push_buf "$c"
}

function iter_files() {
    local file=

    for file in "$@" ; do
        iter_file "$file"
    done
}

function iter_file() {
    local file=$1
    local filesize=$(wc -c <"$file")
    local fileoffset=0

    push_state parsing

    while getc c ; do
        (( ++fileoffset ))

        if [[ $c != $'\n' ]] ; then
            errline+=$c
        fi

        if ! process_char "$c" ; then
            break
        fi

        if [[ $c == $'\n' ]] ; then
            (( ++lineno ))
            charno=1
        else
            (( ++charno ))
            (( ++st_charno ))
        fi

        if [[ $c == $'\n' ]] ; then
            errline=
        fi
    done <"$file"

    pop_state
    flush_buf 1

    if (( st != eof )) ; then
        die "unexpected EOF"
    fi
}

getc_bufsize=4096
getc_buflen=0
getc_offset=0
getc_eof=0

function getc() {
    if (( getc_offset == getc_buflen )) ; then
        if (( getc_eof )) ; then
            return 1
        fi

        if ! read -r -N $getc_bufsize getc_buf ; then
            getc_eof=1
        fi

        getc_buflen=${#getc_buf}
        getc_offset=0
    fi

    printf -v $1 "%c" "${getc_buf:$getc_offset:1}"

    debug_l 2 "${!1}"

    (( ++getc_offset ))
}

function usage() {
    cat <<USAGE
Usage: ${bashpp##*/} [options] file...
Options:
  -I dir                Add the directory defined by dir to the include path.

  -D name               Predefine name as a macro, with definition 1.

  -D name=definition    The contents of definition are tokenized and processed
                        as if they appeared during translation in a #define
                        directive.

                        If you are invoking the preprocessor from a shell or
                        shell-like program you may need to use the shell's
                        quoting syntax to protect characters such as spaces that
                        have a meaning in the shell syntax.

                        -D and -U options are processed in the order they are
                        given on the command line.

  -o file               Place the output into <file>

  -v --verbose          Verbose mode.

  -d --debug            Enable debugging information.

     --debug-level #    Set the debug level to #, default is $DEBUG.

     --debug-from #     Enable debugging information on and after line number #
                        in the source file.

     --max-errors #     Maximum number of errors permitted before stopping.  The
                        default is $ERROR_MAX.

Arguments:
    file                Specify an input file.  By default, input is read from
                        standard input.

Copyright (C) 2015 Craig Phillips.  All rights reserved.
USAGE
}

while (( $# > 0 )) ; do
    case $1 in
    (-I)
        add_include_dir "$2"
        shift
        ;;
    (-I*)
        add_include_dir "${1#-I}"
        ;;
    (-D)
        add_define "$2"
        shift
        ;;
    (-D*)
        add_define "${1#-D}"
        ;;
    (-U)
        remove_define "$2"
        shift
        ;;
    (-U*)
        remove_define "${1#-U}"
        ;;
    (-o)
        output=$(readlink -m "$2")
        shift
        ;;
    (-o*)
        output=$(readlink -m "${1#-o}")
        ;;
    (-v|--verbose)
        (( ++VERBOSE ))
        ;;
    (-d|--debug)
        (( ++DEBUG ))
        ;;
    (--debug-level)
        DEBUG=$2
        shift
        ;;
    (--debug-level=*)
        DEBUG=${1#*=}
        ;;
    (--debug-from)
        DEBUG_LINENO=$2
        shift

        set -- "$@" --debug
        ;;
    (--debug-from=*)
        DEBUG_LINENO=${1#*=}

        set -- "$@" --debug
        ;;
    (--max-errors)
        ERROR_MAX=$2
        shift
        ;;
    (--max-errors=*)
        ERROR_MAX=${1#*=}
        ;;
    (-\?|--help)
        usage
        exit 0
        ;;
    (-*)
        die "illegal option: $1"
        ;;
    (*)
        files+=( "$1" )
        ;;
    esac
    shift
done

if (( ${#files[@]} == 0 )) ; then
    set -- /dev/stdin
fi

iter_files "${files[@]}" >"$output"

if (( errors != 0 )) ; then
    exit 1
fi
