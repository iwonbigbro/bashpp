#!/bin/bash

# Copyright (C) 2015 Craig Phillips.  All rights reserved.

set -euo pipefail

bashpp=$(readlink -f "$BASH_SOURCE")
bashpp_dir=${bashpp%/*}

IFS=":" include_dir=( ${BASHINC:-} )

declare -A DEFS=()
declare -A DEFNS=()

output="/dev/stdout"

verbose=0
errors=0
warnings=0
lineno=0
charno=0

file=
line=
buf=
st=

function aacpy() {
    declare -p $1 | sed 's?^[^=]\+=??'
}

function die() {
    local funcname=${FUNCNAME[1]:-}

    echo >&2 "${bashpp##*/}: error:${funcname:+ $funcname} $*"
    exit 1
}

function msgtype_colour() {
    local on= off=

    if [[ -t 2 ]] ; then
        case $1 in
        (error)   on="[1m[38;5;167m" ;;
        (warning) on="[1m[38;5;213m" ;;
        (info)    on="[1m[38;5;106m" ;;
        esac

        off="[39m[0m"
    fi

    printf "${on}%s${off}" "$1"
}

function msg() {
    local msgtype=$1
    shift

    if [[ ! $file ]] ; then
        local funcname=${FUNCNAME[1]:-}
        printf >&2 "${bashpp##*/}: $msgtype:${funcname:+ $funcname} %s\n" "$*"
    elif [[ $file == "/dev/stdin" ]] ; then
        printf >&2 "<stdin>:$lineno:$charno $msgtype: %s\n" "$*"
    else
        printf >&2 "$file:$lineno:$charno $msgtype: %s\n" "$*"
    fi
}

function err() {
    (( ++errors ))

    if (( lineno == 0 )) ; then
        die "$@"
    fi

    msg "$(msgtype_colour "error")" "$*"
}

function warn() {
    (( ++warnings ))

    msg "$(msgtype_colour "warning")" "$*"
}

function info() {
    if (( verbose )) ; then
        msg "$(msgtype_colour "info")" "$*"
    fi
}

function add_include_dir() {
    if [[ ! $1 ]] ; then
        die "No directory specified"
    elif [[ ! -d $1 ]] ; then
        die "No such directory: $1"
    fi

    if [[ " ${include_dir[*]:-} " != *" $1 "* ]] ; then
        include_dir+=( "$1" )
    fi
}

function definefn() {
    err "macro functions currently not supported"
}

function define() {
    local name=${1%%(*} \
          parens=${1#*(} \
          define=${2:-1}

    if ! [[ $name =~ ^[A-Za-z_][A-Za-z0-9_]+$ ]] ; then
        err "illegal definition name: $name"
    fi

    if [[ $1 == *"("* ]] ; then
        definefn "$name" "${parens%)}" "$define"
        return 0
    fi

    info "-D $name=$define"

    DEFS[$name]=$define
}

function undef() {
    info "-U $1"

    unset DEFS[$1]
    unset DEFNS[$1]
}

function add_define() {
    local name=${1%%=*} \
          define=${1#*=}

    if [[ $1 == *"="* ]] ; then
        define "${1%%=*}" "${1#*=}"
    else
        define "$1" 1
    fi
}

function remove_define() {
    undef "$1"
}

parsing=0
found_word=1
found_directive=2

function set_state() {
    st=${!1}
}

function process_char() {
    local c=$1 def=

    if (( st == parsing )) ; then
        if [[ $c == [A-Za-z_] ]] ; then
            set_state found_word

            buf+=$c

            return
        fi
    fi

    if (( st == found_word )) ; then
        if [[ $c == [A-Za-z_] ]] ; then
            buf+=$c

            return

        elif [[ $buf ]] ; then
            def=${DEFS[$buf]:-}

            if [[ $def ]] ; then
                info "substituting '$buf' for '$def'"
                buf=$def
            fi

            printf "%s" "$buf"
            buf=
        fi

        set_state parsing
    fi

    printf "%s" "$c"
}

function process_line() {
    local i= c=

    for (( i = 0 ; i < ${#line} ; ++i )) ; do
        char=$i
        process_char "${line:$i:1}"
    done

    process_char $'\n'
}

function iter_lines() {
    local curlineno=$lineno
    local curline=$line
    local curbuf=$buf
    local curst=$st

    lineno=0
    buf=

    set_state parsing

    while IFS=$'\x00' read -r line ; do
        (( ++lineno ))

        process_line
    done <"$file"

    st=$curst
    buf=$curbuf
    line=$curline
    lineno=$curlineno
}

function iter_files() {
    local curfile=$file

    for file in "$@" ; do
        iter_lines
    done

    file=$curfile
}

function usage() {
    cat <<USAGE
Usage: ${bashpp##*/} [options] file...
Options:
  -I dir                Add the directory defined by dir to the include path.

  -D name               Predefine name as a macro, with definition 1.

  -D name=definition    The contents of definition are tokenized and processed
                        as if they appeared during translation in a #define
                        directive.

                        If you are invoking the preprocessor from a shell or
                        shell-like program you may need to use the shell's
                        quoting syntax to protect characters such as spaces that
                        have a meaning in the shell syntax.

                        -D and -U options are processed in the order they are
                        given on the command line.

  -o file               Place the output into <file>

  -v                    Verbose mode.

Arguments:
    file                Specify an input file.  By default, input is read from
                        standard input.

Copyright (C) 2015 Craig Phillips.  All rights reserved.
USAGE
}

while (( $# > 0 )) ; do
    case $1 in
    (-I)
        add_include_dir "$2"
        shift
        ;;
    (-I*)
        add_include_dir "${1#-I}"
        ;;
    (-D)
        add_define "$2"
        shift
        ;;
    (-D*)
        add_define "${1#-D}"
        ;;
    (-U)
        remove_define "$2"
        shift
        ;;
    (-U*)
        remove_define "${1#-U}"
        ;;
    (-o)
        output=$(readlink -m "$2")
        shift
        ;;
    (-o*)
        output=$(readlink -m "${1#-o}")
        ;;
    (-v)
        (( ++verbose ))
        ;;
    (-\?|--help)
        usage
        exit 0
        ;;
    (-*)
        err "Illegal option: $1"
        ;;
    (*)
        break
        ;;
    esac
    shift
done

if (( $# == 0 )) ; then
    set -- /dev/stdin
fi

iter_files "$@" >"$output"
