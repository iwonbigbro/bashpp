#!/bin/bash

# Copyright (C) 2015 Craig Phillips.  All rights reserved.

set -euo pipefail

bashpp=$(readlink -f "$BASH_SOURCE")
bashpp_dir=${bashpp%/*}

BASHINC=${BASHINC:-}

declare -A DEFS=()
declare -A MACROS=()
declare -A DIRS=(
    ["define"]=1
    ["undef"]=1
)

output="/dev/stdout"

VERBOSE=${VERBOSE:-0}
DEBUG=${DEBUG:-0}

errors=0
warnings=0
lineno=1
charno=1

states=0
while read state ; do
    printf -v $state "%d" $states

    (( ++states ))
done <<STATES
apos
arithmetic
bracket_s
bracket_c
comment
directive
directive_escape
dollar
escape
escape_sequence
expandbrace
expandcmd
expandparam
expandvar
heredoc
heredoc_start
logic
number
parens
parsing
quote
word
eof
STATES

unset state
state_stack=( "eof" )
state_stackbuf=()
state_stacklen=0
st_name=
st_buf=
st_buf_prev=
st=-1

heredoc_tag=
heredoc_type=

flushbuf=0
freezebuf=0

file=
line=
buf=

function aacpy() {
    declare -p $1 | sed 's?^[^=]\+=??'
}

function msgtype_colour() {
    local on= off=

    if [[ -t 2 ]] ; then
        case $1 in
        (error)   on="[1m[38;5;167m" ;;
        (warning) on="[1m[38;5;213m" ;;
        (info)    on="[1m[38;5;106m" ;;
        (debug)   on="[1m[38;5;105m" ;;
        esac

        off="[39m[0m"
    fi

    printf "${on}%s${off}" "$1"
}

function bashpp_msg() {
    local msgtype=$1
    shift

    local funcname=${FUNCNAME[1]:-main}

    if [[ $funcname == +(msg|die|debug|info|warn) ]] ; then
        funcname=${FUNCNAME[2]:-main}
    fi

    printf >&2 "${bashpp##*/}: $msgtype:${funcname:+ $funcname:} %s\n" "$*"
}

function msg() {
    local msgtype=$1
    shift

    if [[ ! $file ]] ; then
        bashpp_msg "$msgtype" "$*"
    elif [[ $file == "/dev/stdin" ]] ; then
        printf >&2 "<stdin>:$lineno:$charno $msgtype: %s\n" "$*"
    else
        printf >&2 "$file:$lineno:$charno $msgtype: %s\n" "$*"
    fi
}

function err() {
    (( ++errors ))

    if (( lineno == 0 )) ; then
        die "$@"
    fi

    msg "$(msgtype_colour "error")" "$*"
}

function die() {
    local funcname=${FUNCNAME[1]:-}
          funcname=${funcname:+$funcname }

    bashpp_msg "$(msgtype_colour "error")" "$*"
    stacktrace

    bashpp_msg "$(msgtype_colour "error")" "$*"

    exit 1
}

function warn() {
    (( ++warnings ))

    msg "$(msgtype_colour "warning")" "$*"
}

function info() {
    if (( VERBOSE )) ; then
        msg "$(msgtype_colour "info")" "$*"
    fi
}

function debug() {
    local funcname=${FUNCNAME[1]:-main}

    if (( DEBUG )) ; then
        msg "$(msgtype_colour "debug")" "$funcname(): $*"
    fi
}

function stacktrace() {
    local i=

    printf >&2 "[1m[38;5;167mTraceback:[0m\n"

    if (( $# )) ; then
        printf >&2 "  [38;5;167m%s:%d: %s()[0m\n" "$@"
    fi

    for (( i = 1 ; i < ${#BASH_LINENO[@]} ; ++i )) ; do
        printf >&2 "  [38;5;167m%s:%d: %s()[0m\n" \
            "${BASH_SOURCE[i+1]:-$BASH_SOURCE}" "${BASH_LINENO[i]}" "${FUNCNAME[i]}"
    done
}

set -E
trap 'stacktrace "$BASH_SOURCE" "$LINENO" "${FUNCNAME:-main}"' ERR

function add_include_dir() {
    if [[ ! $1 ]] ; then
        die "No directory specified"
    elif [[ ! -d $1 ]] ; then
        die "No such directory: $1"
    fi

    if [[ ":${BASHINC:-}:" != *":$1:"* ]] ; then
        BASHINC+=":$1"
    fi
}

function definefn() {
    err "macro functions currently not supported"
}

function is_define() {
    (( ${#DEFS[$1]:-} > 0 ))
}

function is_macro() {
    (( ${#MACROS[$1]:-} > 0 ))
}

function define() {
    local name=${1%%(*} \
          parens=${1#*(} \
          define=${2:-1}

    if ! [[ $name =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]] ; then
        err "illegal definition name: $name"
    fi

    if [[ $1 == *"("* ]] ; then
        definefn "$name" "${parens%)}" "$define"
        return 0
    fi

    info "-D $name=$define"

    DEFS[$name]=$define
}

function undef() {
    info "-U $1"

    unset DEFS[$1]
    unset MACROS[$1]
}

function add_define() {
    local name=${1%%=*} \
          define=${1#*=}

    if [[ $1 == *"="* ]] ; then
        define "${1%%=*}" "${1#*=}"
    else
        define "$1" 1
    fi
}

function remove_define() {
    undef "$1"
}

function push_state() {
    IFS=: debug "${state_stack[@]}:$st_name -> ${state_stack[@]}:$st_name:$1"

    state_stackbuf+=( "$st_buf" )
    state_stack+=( $st_name )

    (( ++state_stacklen )) || true

    st=${!1}
    st_name=$1
    st_buf_prev=$st_buf
    st_buf=
}

function pop_state() {
    IFS=: debug "${state_stack[@]}:$st_name -> ${state_stack[@]}"

    if (( ${#state_stack[@]} == 0 )) ; then
        die "state_stack accounting error"
    fi

    st_name=${state_stack[-1]}
    st_buf_prev=$st_buf
    st_buf=${state_stackbuf[-1]}
    st=${!st_name}

    unset state_stack[-1]
    unset state_stackbuf[-1]

    (( --state_stacklen )) || true
}

function switch_state() {
    IFS=: debug "${state_stack[@]}:$st_name -> ${state_stack[@]}:$1"

    st=${!1}
    st_name=$1
}

function freeze_buf() {
    debug
    freezebuf=1
}

function thaw_buf() {
    debug
    freezebuf=0
}

function push_buf() {
    st_buf+=$1

    if (( freezebuf == 1 )) ; then
        debug "frozen: '$st_buf'"
    else
        buf+=$1

        if (( flushbuf || ${#buf} > 4096 )) ; then
            printf "%s" "$buf"

            flushbuf=0
            buf=
        fi
    fi
}

function flush_buf() {
    if (( ${1:-0} )) ; then
        printf "%s" "$buf"

        flushbuf=0
        buf=
    else
        flushbuf=1
    fi
}

function process_define() {
    local args=$1

    if [[ $args =~ ^([A-Za-z_][A-Za-z0-9_]*)[\ \t]+(.*)$ ]] ; then
        define "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
        return

    elif [[ $args =~ ^([A-Za-z_][A-Za-z0-9_]*)$ ]] ; then
        define "${BASH_REMATCH[1]}" 1
        return

    fi

    err "illegal define: $line"

    return 1
}

function process_char() {
    local c=$1

    if [[ $c == '' ]] ; then
        push_state escape_sequence
        push_buf "$c"

        return 0
    fi

    if (( st == apos )) ; then
        if [[ $c == "'" ]] ; then
            pop_state
        fi
    elif (( st == arithmetic )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == '(' ]] ; then
            push_state parens
        elif [[ $c == ')' && ${st_buf: -1} == ')' ]] ; then
            pop_state
        elif [[ ${st_buf: -1} == ')' ]] ; then
            err "unmatched parenthesis"
        fi
    elif (( st == bracket_c )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == '}' ]] ; then
            pop_state
        fi
    elif (( st == bracket_s )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == '[' ]] ; then
            switch_state logic
        elif [[ $c == ']' ]] ; then
            pop_state
        fi
    elif (( st == comment )) ; then
        if [[ $c == $'\n' ]] ; then
            pop_state
        fi
    elif (( st == directive )) ; then
        if (( charno == 2 )) && [[ $c != [a-z] ]] ; then
            thaw_buf
            switch_state comment
            push_buf "$st_buf"
        elif [[ $c == '\' ]] ; then
            push_state directive_escape
        elif [[ $c == $'\n' ]] ; then
            thaw_buf

            local directive= directive_params=

            read directive directive_params <<<"${st_buf:1}"

            pop_state

            if (( ${DIRS[$directive]:-0} == 1 )) ; then
                if process_$directive "$directive_params" ; then
                    return 0
                fi
            else
                err "invalid directive: $directive"
            fi

            push_buf "$st_buf_prev"
        fi
    elif (( st == directive_escape )) ; then
        pop_state
        push_buf "\\$c"
        
        return 0
    elif (( st == dollar )) ; then
        pop_state

        if [[ $c == [*@\#\?\-\$\!0-9] ]] ; then
            true
        elif [[ $c == "'" ]] ; then
            push_state apos
        elif [[ $c == '"' ]] ; then
            push_state quote
        elif [[ $c == '{' ]] ; then
            push_state expandparam
        elif [[ $c == '(' ]] ; then
            push_state expandcmd
        elif [[ $c == [A-Za-z_] ]] ; then
            push_state expandvar
        else
            err "unexpected character after: '${st_buf: -1}'"
        fi
    elif (( st == escape )) ; then
        push_buf "$c"
        pop_state

        return 0
    elif (( st == escape_sequence )) ; then
        push_buf "$c"

        if (( charno == 1 )) && [[ $c != '[' ]] ; then
            pop_state

            err "unexpected character after: '${st_buf: -1}'"
        elif [[ $c == 'm' ]] ; then
            pop_state
        fi

        return 0
    elif (( st == expandcmd )) ; then
        if (( ${#st_buf} == 1 )) && [[ $c == '(' ]] ; then
            switch_state arithmetic
        elif [[ $c == ')' ]] ; then
            pop_state
        fi
    elif (( st == expandparam )) ; then
        if (( ${#st_buf} == 1 )) ; then
            if [[ $c != [A-Za-z0-9_] ]] ; then
                err "malformed parameter expansion expression"
            fi
        elif (( ${#st_buf} == 2 )) && [[ $st_buf == [0-9] ]] ; then
            if [[ $c != '}' ]] ; then
                err "malformed parameter expansion expression"
            fi

        # TODO: Handle expressions.

        elif [[ $c == '}' ]] ; then
            pop_state
        fi
    elif (( st == expandvar )) ; then
        if [[ $c != [A-Za-z0-9_] ]] ; then
            pop_state
            process_char "$c"

            return 0
        fi
    elif (( st == heredoc )) ; then
        true
    elif (( st == heredoc_start )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == "'" ]] ; then
            push_state apos

            heredoc_type=$apos
        elif [[ $c == '"' ]] ; then
            push_state quote
        elif [[ $c == [\ \t] ]] ; then
            heredoc_tag=${st_buf//[\"\']/}
        fi
    elif (( st == logic )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == "'" ]] ; then
            push_state apos
        elif [[ $c == '"' ]] ; then
            push_state quote
        elif [[ $c == '(' ]] ; then
            push_state parens
        elif [[ $c == ')' && ${st_buf: -1} == ')' ]] ; then
            pop_state
        elif [[ $c == ']' && ${st_buf: -1} == ']' ]] ; then
            pop_state
        elif [[ ${st_buf: -1} == ']' ]] ; then
            err "unexpected character after: '${st_buf: -1}'"
        elif [[ ${st_buf: -1} == ')' ]] ; then
            err "unmatched parenthesis"
        fi
    elif (( st == number )) ; then
        if [[ $c != [0-9] ]] ; then
            pop_state
            process_char "$c"

            return 0
        fi
    elif (( st == parens )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == '(' ]] ; then
            switch_state arithmetic
        elif [[ $c == ')' ]] ; then
            pop_state
        fi
    elif (( st == parsing )) ; then
        if [[ $c == '#' ]] ; then
            if (( charno == 1 )) ; then
                push_state directive
                freeze_buf
            else
                push_state comment
            fi
        elif [[ $c == '$' ]] ; then
            push_state dollar
        elif [[ $c == '(' ]] ; then
            push_state parens
        elif [[ $c == '{' ]] ; then
            push_state bracket_c
        elif [[ $c == '[' ]] ; then
            push_state bracket_s
        elif [[ $c == '"' ]] ; then
            push_state quote
        elif [[ $c == "'" ]] ; then
            push_state apos
        elif [[ $c == [A-Za-z_] ]] ; then
            push_state word
            freeze_buf
        fi
    elif (( st == quote )) ; then
        if [[ $c == '\' ]] ; then
            push_state escape
        elif [[ $c == '$' ]] ; then
            push_state dollar
        elif [[ $c == '"' ]] ; then
            pop_state
        fi
    elif (( st == word )) ; then
        if [[ $c != [0-9A-Za-z_] ]] ; then
            pop_state
            thaw_buf

            if is_define "$st_buf_prev" ; then
                push_buf "${DEFS[$st_buf_prev]}"
            else
                push_buf "$st_buf_prev"
            fi

            process_char "$c"

            return 0
        fi
    elif (( st == parse_until )) ; then
        if [[ $c == "$parse_until_char" ]] ; then
            pop_state
        fi
    fi

    push_buf "$c"
}

function iter_files() {
    local file=

    for file in "$@" ; do
        iter_file <"$file"
        flush_buf 1
    done
}

function iter_file() {
    push_state parsing

    while getc c ; do
        if ! process_char "$c" ; then
            break
        fi

        if [[ $c == $'\n' ]] ; then
            (( ++lineno ))
            charno=1
        else
            (( ++charno ))
        fi
    done

    pop_state

    if (( st != eof )) ; then
        err "unexpected EOF"
    fi
}

getc_bufsize=4096
getc_buflen=0
getc_offset=0
getc_eof=0

function getc() {
    if (( getc_offset == getc_buflen )) ; then
        if (( getc_eof )) ; then
            return 1
        fi

        if ! read -r -N $getc_bufsize getc_buf ; then
            getc_eof=1
        fi

        getc_buflen=${#getc_buf}
        getc_offset=0
    fi

    printf -v $1 "%c" "${getc_buf:${getc_offset}:1}"

    (( ++getc_offset ))
}

function usage() {
    cat <<USAGE
Usage: ${bashpp##*/} [options] file...
Options:
  -I dir                Add the directory defined by dir to the include path.

  -D name               Predefine name as a macro, with definition 1.

  -D name=definition    The contents of definition are tokenized and processed
                        as if they appeared during translation in a #define
                        directive.

                        If you are invoking the preprocessor from a shell or
                        shell-like program you may need to use the shell's
                        quoting syntax to protect characters such as spaces that
                        have a meaning in the shell syntax.

                        -D and -U options are processed in the order they are
                        given on the command line.

  -o file               Place the output into <file>

  -v --verbose          Verbose mode.

     --debug            Enable debugging information.

Arguments:
    file                Specify an input file.  By default, input is read from
                        standard input.

Copyright (C) 2015 Craig Phillips.  All rights reserved.
USAGE
}

while (( $# > 0 )) ; do
    case $1 in
    (-I)
        add_include_dir "$2"
        shift
        ;;
    (-I*)
        add_include_dir "${1#-I}"
        ;;
    (-D)
        add_define "$2"
        shift
        ;;
    (-D*)
        add_define "${1#-D}"
        ;;
    (-U)
        remove_define "$2"
        shift
        ;;
    (-U*)
        remove_define "${1#-U}"
        ;;
    (-o)
        output=$(readlink -m "$2")
        shift
        ;;
    (-o*)
        output=$(readlink -m "${1#-o}")
        ;;
    (-v|--verbose)
        (( ++VERBOSE ))
        ;;
    (--debug)
        (( ++DEBUG ))
        ;;
    (-\?|--help)
        usage
        exit 0
        ;;
    (-*)
        err "Illegal option: $1"
        ;;
    (*)
        break
        ;;
    esac
    shift
done

if (( $# == 0 )) ; then
    set -- /dev/stdin
fi

iter_files "$@" >"$output"

if (( errors != 0 )) ; then
    exit 1
fi
